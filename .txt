#include "MoveGenerator.hpp"

bool searchVector(std::vector<int> &v, int i)
{
    for (int k = 0; k < v.size(); k++)
    {
        if (v[k] == i)
        {
            return true;
        }
    }
    return false;
}

void MoveGenerator::generateMovesInCurrentPosition()
{
    std::vector<CheckOrPin> pins;
    std::vector<CheckOrPin> checks;
    Square **board = boardReference->getBoard();
    bool inCheck = false;

    this->checkForPinsAndChecks(pins, checks, inCheck);
    boardReference->setPins(pins);
    boardReference->setChecks(checks);
    boardReference->setCheckFlag(inCheck);

    std::map<int, std::vector<Move>> moves;
    Piece *kingPiece = boardReference->getWhiteToMove() ? boardReference->getWhiteKing() : boardReference->getBlackKing();

    if (inCheck)
    {

        if (checks.size() == 1) // if there is exactly one check location
        {
            moves = pieceAvailableMoves();
            // to block check a piece has to move between the attacking piece and king
            auto check = checks[0];
            int checkPosition = check.position;
            int checkDirection = check.direction;

            Piece *checkingPiece = board[checkPosition]->getPiece();
            std::vector<int> validSquares;

            if (checkingPiece->getPieceType() == Piece::KNIGHT)
            {
                validSquares.push_back(checkPosition);
            }
            else
            {
                for (int i = 0; i < 8; i++)
                {
                    int validSquare = kingPiece->getPiecePosition() + checkDirection * i;
                    validSquares.push_back(validSquare);
                    if (validSquare == checkPosition)
                        break;
                }
            }
            // redo this function to iterate through the map properly
            for (const auto &[key, val] : moves)
            {
                if (val.empty())
                    continue;

                int pieceLocation = val[0].start;
                Piece *piece = board[pieceLocation]->getPiece();

                if (piece->getPieceType() != Piece::KING) // the king isn't moving so another piece has to block or capture
                {
                    std::vector<Move> allowedMoves;
                    for (int j = 0; j < val.size(); j++)
                    {
                        Move move = val[j];
                        if (searchVector(validSquares, move.target)) // if the target square is not in the valid moves square
                        {
                            allowedMoves.push_back(val[j]);
                        }
                    }
                    moves[key] = allowedMoves;
                }
            }
        }
        else // double check king has to move
        {

            auto kingMoves = getKingMoves(kingPiece);
            moves[kingPiece->getPiecePosition()] = kingMoves;
        }
    }
    else
    {
        // not in check
        moves = pieceAvailableMoves();
    }

    boardReference->setMoveSet(moves);
}

void MoveGenerator::checkForPinsAndChecks(std::vector<CheckOrPin> &pins, std::vector<CheckOrPin> &checks, bool &inCheck)
{
    inCheck = false;
    int enemyColor = whiteToMove ? Piece::BLACK : Piece::WHITE;
    int allyColor = whiteToMove ? Piece::WHITE : Piece::BLACK;
    Piece *kingPiece = whiteToMove ? whiteKing : blackKing;
    int kingPosition = kingPiece->getPiecePosition();
    // const int slidingMovesOffsets[8] = {1, -1, 8, -8, 7, -7, 9, -9};
    // check all directions from the king
    for (int i = 0; i < 8; i++)
    {
        CheckOrPin possiblePin;
        bool pinExists = false;
        for (int j = 0; j < numSquaresToEdge[kingPosition][i]; j++)
        {
            int target = kingPosition + slidingMovesOffsets[i] * (j + 1);
            if (board[target]->hasNullPiece())
                continue;

            Piece *curr = board[target]->getPiece();
            if (curr->getPieceColor() == allyColor && curr->getPieceType() != Piece::KING)
            {
                if (!pinExists)
                {
                    possiblePin.position = target;
                    possiblePin.direction = slidingMovesOffsets[i];
                    pinExists = true;
                }
                else
                {
                    possiblePin.position = -1111;
                    possiblePin.direction = -1111;
                    pinExists = false;
                    break; // second ally piece so no pin or check is possible
                }
            }
            else if (curr->getPieceColor() == enemyColor)
            {
                // orthogonal away from king is rook
                // diagnol away from king is bishop
                // 1 square away from king is pawn
                // any square away can be a queen
                // any direction 1 square away is king

                int pieceType = curr->getPieceType();
                if ((pieceType == Piece::ROOK && i <= 3) || (pieceType == Piece::BISHOP && i >= 4) || (j == 0 && pieceType == Piece::PAWN && ((enemyColor == Piece::WHITE and (i == 4 || i == 6)) || (enemyColor == Piece::BLACK and (i == 5 || i == 7)))) || pieceType == Piece::QUEEN || (j == 0 && pieceType == Piece::KING))
                {

                    if (!pinExists) // piece is in check
                    {
                        inCheck = true;
                        checks.push_back(CheckOrPin(target, slidingMovesOffsets[i]));
                        break;
                    }
                    else // piece is pinned
                    {
                        pins.push_back(possiblePin);
                        break;
                    }
                }
                break;
            }
        }
    }

    // check knight moves on king
    // const int knightOffset[8] = {6, 10, 15, 17, -6, -10, -15, -17};
    int rank = kingPosition / 8;
    int file = kingPosition % 8;
    for (int i = 0; i < 8; i++)
    {
        int target = kingPosition + knightOffset[i];
        if (target >= 64 || target < 0)
            continue;
        if (board[target]->hasNullPiece())
            continue;

        int knightRank = target / 8;
        int knightFile = target % 8;

        // makes sure knight doesnt wrap around the edge of the board
        int maxJumpCoord = std::max(std::abs(file - knightFile), std::abs(rank - knightRank));
        if (maxJumpCoord != 2)
            continue;

        Piece *endPiece = board[target]->getPiece();

        if (endPiece->getPieceColor() == enemyColor && endPiece->getPieceType() == Piece::KNIGHT)
        {
            inCheck = true;
            checks.push_back(CheckOrPin(target, knightOffset[i]));
        }
    }
}

std::map<int, std::vector<Move>> MoveGenerator::pieceAvailableMoves()
{

    std::map<int, std::vector<Move>> positionMoves;
    int colorToMove = whiteToMove ? Piece::WHITE : Piece::BLACK;

    for (int i = 0; i < 64; i++)
    {
        if (board[i]->hasNullPiece())
            continue;

        Piece *piece = board[i]->getPiece();
        if (piece->getPieceColor() != colorToMove)
            continue;

        std::vector<Move> pieceMoves;

        int pieceType = piece->getPieceType();
        if (pieceType == Piece::QUEEN || pieceType == Piece::BISHOP || pieceType == Piece::ROOK)
        {
            pieceMoves = getSlidingTypeMoves(piece);
        }
        else if (pieceType == Piece::KNIGHT)
        {
            pieceMoves = getKnightMoves(piece);
        }
        else if (pieceType == Piece::PAWN)
        {
            pieceMoves = getPawnMoves(piece);
        }
        positionMoves[i] = pieceMoves;
    }
    this->moveset = positionMoves;
    auto whiteKingMoves = getKingMoves(whiteKing);
    auto blackKingMoves = getKingMoves(blackKing);
    moveset[whiteKing->getPiecePosition()] = whiteKingMoves;
    moveset[blackKing->getPiecePosition()] = blackKingMoves;

    return moveset;
}